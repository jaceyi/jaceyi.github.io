<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="keywords"
    content="jaceyi,yijinchun,Jace,JaceYi,Jace Yi,易进春,易进春的博客,yi个程序猿,前端,前端开发,前端博客,JavaScript,React">
  <meta name="description" content="易进春的个人博客，分享日常生活、学习笔记和踩过的那些坑~" />
  <title>详解 React useCallback & useMemo - 易进春的博客【Web前端开发】</title>
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="stylesheet" href="/css/prism.css">
  <link rel="stylesheet" href="/css/base.css">
  <link rel="stylesheet" href="/css/post.css">
  <script src="/js/util.js"></script>
</head>

<body>
  <div id="header" style="background-image: url(/static/images/bg4.jpg)">
    <div class="bar">
  <div class="title">
    <a href="/">Jace's Blog</a>
  </div>
  <nav class="nav">
    <div class="item">
      <a href="/">Home</a>
    </div>
    <div class="item">
      <a href="/tags">Tags</a>
    </div>
    <div class="item">
      <a href="/about">About</a>
    </div>
  </nav>
  <div class="mobile-nav">
    <div class="mobile-nav-menu icon">
      <i class="iconfont">&#xe633;</i>
    </div>
    <div class="mobile-nav-box">
      <a href="/">Home</a>
      <a href="/tags">Tags</a>
      <a href="/about">About</a>
    </div>
  </div>
</div>

<script>
  (function (d, w) {
    w.onload = function () {
      var $menuIcon = d.querySelector('.mobile-nav-menu');
      var $navBox = d.querySelector('.mobile-nav-box');
      var animationEndCallback = null;
      function hideNavBox() {
        addClass($navBox, 'zoomOut');
        animationEndCallback = function () {
          removeClass($navBox, 'zoomOut');
          $navBox.style.display = 'none';
        }
      }

      $menuIcon.onclick = function (e) {
        e.stopPropagation();
        if ($navBox.style.display === 'block') return hideNavBox();
        $navBox.style.display = 'block';
        addClass($navBox, 'zoomIn');
        animationEndCallback = function () {
          removeClass($navBox, 'zoomIn');
        }
      };

      $navBox.onclick = function (e) {
        e.stopPropagation();
      };

      $navBox.addEventListener('animationend', function (e) {
        animationEndCallback && animationEndCallback();
      }, false);

      d.body.addEventListener('click', function () {
        if ($navBox.style.display === 'block') hideNavBox();
      }, false);

      var $header = d.querySelector('#header');
      var $bar = d.querySelector('.bar');
      var barHeight = $bar.offsetHeight;
      w.addEventListener('scroll', function (e) {
        var scrollTop = d.documentElement.scrollTop || d.body.scrollTop;
        var step = $header.className.indexOf('visible') >= 0 ? barHeight : 0;
        if (scrollTop > $header.offsetHeight - step) {
          addClass($header, 'active');
        } else {
          removeClass($header, 'active');
        }
      }, false);

      d.addEventListener('mousewheel', function (e) {
        if (e.target.tagName === 'BODY') {
          if (e.wheelDeltaY >= 0) {
            addClass($header, 'visible');
          } else {
            removeClass($header, 'visible');
          }
        }
      })
    }
  })(document, window);
</script>

    <div class="content">
      <h1 class="post-title">详解 React useCallback & useMemo</h1>
      <div class="post-description">本文详细的讲述了 useCallback 与 useMemo 的使用场景，以及有哪些使用中常遇到的问题与采坑点。</div>
      <div class="post-date">2020-03-24</div>
      <div class="tags">
        
        <a class="tag" href="/tags/#JavaScript" title="JavaScript">JavaScript</a>
        
        <a class="tag" href="/tags/#React" title="React">React</a>
        
      </div>
    </div>
  </div>

  <div class="container">
    <div class="main">
      <div class="article">
        <h2 id="前言">前言</h2>

<p>阅读本文章需要对 <a href="https://reactjs.org/docs/hooks-intro.html">React hooks</a> 中 <a href="https://reactjs.org/docs/hooks-state.html">useState</a> 和 <a href="https://reactjs.org/docs/hooks-effect.html">useEffect</a> 有基础的了解。我的这篇文章内有大致介绍 <a href="https://juejin.cn/post/6844904093824073742">在 React 项目中全量使用 Hooks</a>。</p>

<!--more-->

<h2 id="usecallback">useCallback</h2>

<h3 id="usecallback-的作用">useCallback 的作用</h3>

<p>官方文档：</p>

<blockquote>
  <p>Pass an inline callback and an array of dependencies. useCallback will return a memoized version of the callback that only changes if one of the dependencies has changed.</p>
</blockquote>

<p>简单来说就是返回一个函数，只有在依赖项发生变化的时候才会更新（返回一个新的函数）。</p>

<h3 id="usecallback-的应用">useCallback 的应用</h3>

<p>在线代码： <a href="https://codesandbox.io/s/usecallback1-yu1sp">Code Sandbox</a></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span><span class="p">,</span> <span class="nx">useCallback</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Button</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./Button</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count1</span><span class="p">,</span> <span class="nx">setCount1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count2</span><span class="p">,</span> <span class="nx">setCount2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count3</span><span class="p">,</span> <span class="nx">setCount3</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">handleClickButton1</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setCount1</span><span class="p">(</span><span class="nx">count1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="kd">const</span> <span class="nx">handleClickButton2</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setCount2</span><span class="p">(</span><span class="nx">count2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">},</span> <span class="p">[</span><span class="nx">count2</span><span class="p">]);</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">Button</span> <span class="nx">onClickButton</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClickButton1</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Button1</span><span class="o">&lt;</span><span class="sr">/Button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">Button</span> <span class="nx">onClickButton</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClickButton2</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Button2</span><span class="o">&lt;</span><span class="sr">/Button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">Button</span>
          <span class="nx">onClickButton</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">setCount3</span><span class="p">(</span><span class="nx">count3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
          <span class="p">}}</span>
        <span class="o">&gt;</span>
          <span class="nx">Button3</span>
        <span class="o">&lt;</span><span class="sr">/Button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Button.jsx</span>
<span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">Button</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">onClickButton</span><span class="p">,</span> <span class="nx">children</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">onClickButton</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">children</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;</span><span class="p">{</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()}</span><span class="o">&lt;</span><span class="sr">/span</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(</span><span class="nx">Button</span><span class="p">);</span>
</code></pre></div></div>

<p>在案例中可以分别点击 Demo 中的几个按钮来查看效果：</p>

<ul>
  <li>点击 Button1 的时候只会更新 Button1 和 Button3 后面的内容;</li>
  <li>点击 Button2 会将三个按钮后的内容都更新;</li>
  <li>点击 Button3 的也是只更新 Button1 和 Button3 后面的内容。</li>
</ul>

<p>上述效果仔细理一理就可以发现，只有经过 <code class="language-plaintext highlighter-rouge">useCallback</code> 优化后的 Button2 是点击自身时才会变更，其他的两个只要父组件更新后都会变更（这里 Button1 和 Button3 其实是一样的，无非就是函数换了个地方写）。下面我们仔细看看具体的优化逻辑。</p>

<blockquote>
  <p>这里或许会注意到 Button 组件的 <strong><a href="https://reactjs.org/docs/react-api.html#reactmemo"><code class="language-plaintext highlighter-rouge">React.memo</code></a></strong> 这个方法，此方法内会对 props 做一个浅层比较，如果如果 props 没有发生改变，则不会重新渲染此组件。</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const a = () =&gt; {};
const b = () =&gt; {};
a === b; // false
</code></pre></div></div>

<p>上述代码可以看到我们两个一样的函数却是不相等的（这是个废话，我相信能看到这的人都知道，所以不做解释了）。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">count1</span><span class="p">,</span> <span class="nx">setCount1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="kd">const</span> <span class="nx">handleClickButton1</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setCount1</span><span class="p">(</span><span class="nx">count1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="c1">// ...</span>
<span class="k">return</span> <span class="o">&lt;</span><span class="nx">Button</span> <span class="nx">onClickButton</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClickButton1</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Button1</span><span class="o">&lt;</span><span class="sr">/Button&gt;</span><span class="err">;
</span></code></pre></div></div>

<p>回头再看上面的 <code class="language-plaintext highlighter-rouge">Button</code> 组件都需要一个 <code class="language-plaintext highlighter-rouge">onClickButton</code> 的 props ，尽管组件内部有用 <code class="language-plaintext highlighter-rouge">React.memo</code> 来做优化，但是我们声明的 <code class="language-plaintext highlighter-rouge">handleClickButton1</code> 是直接定义了一个方法，这也就导致只要是父组件重新渲染（状态或者 props 更新）就会导致这里声明出一个新的方法，新的方法和旧的方法尽管长的一样，但是依旧是两个不同的对象，<code class="language-plaintext highlighter-rouge">React.memo</code> 对比后发现对象 props 改变，就重新渲染了。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleClickButton2</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setCount2</span><span class="p">(</span><span class="nx">count2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">count2</span><span class="p">]);</span>
</code></pre></div></div>

<p>上述代码我们的方法使用 useCallback 包装了一层，并且后面还传入了一个 <code class="language-plaintext highlighter-rouge">[count2]</code> 变量，这里 useCallback 就会根据 <code class="language-plaintext highlighter-rouge">count2</code> 是否发生变化，从而决定是否返回一个新的函数，函数<strong>内部作用域</strong>也随之更新。</p>

<p>由于我们的这个方法只依赖了 <code class="language-plaintext highlighter-rouge">count2</code> 这个变量，而且 <code class="language-plaintext highlighter-rouge">count2</code> <strong>只在</strong>点击 Button2 后才会更新 <code class="language-plaintext highlighter-rouge">handleClickButton2</code>，所以就导致了我们点击 Button1 不重新渲染 Button2 的内容。</p>

<h3 id="tips">Tips</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span><span class="p">,</span> <span class="nx">useCallback</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Button</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./Button</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count2</span><span class="p">,</span> <span class="nx">setCount2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">handleClickButton2</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setCount2</span><span class="p">(</span><span class="nx">count2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">},</span> <span class="p">[]);</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Button</span> <span class="nx">count</span><span class="o">=</span><span class="p">{</span><span class="nx">count2</span><span class="p">}</span> <span class="nx">onClickButton</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClickButton2</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="nx">Button2</span>
    <span class="o">&lt;</span><span class="sr">/Button</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们调整了一下代码，将 useCallback 依赖的第二个参数变成了一个<strong>空的数组</strong>，这也就意味着这个方法没有依赖值，将不会被更新。且由于 JS 的静态作用域导致此函数内 <code class="language-plaintext highlighter-rouge">count2</code> 永远都 <code class="language-plaintext highlighter-rouge">0</code>。</p>

<p>可以点击多次 Button2 查看变化，会发现 Button2 后面的值只会改变一次。因为上述函数内的 <code class="language-plaintext highlighter-rouge">count2</code> 永远都是 <code class="language-plaintext highlighter-rouge">0</code>，就意味着每次都是 <code class="language-plaintext highlighter-rouge">0 + 1</code>，Button 所接受的 <code class="language-plaintext highlighter-rouge">count</code> props，也只会从 <code class="language-plaintext highlighter-rouge">0</code> 变成 <code class="language-plaintext highlighter-rouge">1</code>且一直都将是 <code class="language-plaintext highlighter-rouge">1</code>，而且 <code class="language-plaintext highlighter-rouge">handleClickButton2</code> 也因没有依赖项不会返回新的方法，就导致 Button 组件只会因 <code class="language-plaintext highlighter-rouge">count</code> 改变而更新一次。</p>

<hr />

<p>上述提到的是不更新所带来的问题，接下来在看一个频繁更新所带来的问题。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">text</span><span class="p">,</span> <span class="nx">setText</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">text</span><span class="p">]);</span>

<span class="k">return</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">form</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">setText</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">)}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">OtherForm</span> <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="nx">handleSubmit</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/form</span><span class="err">&gt;
</span><span class="p">);</span>
</code></pre></div></div>

<p>上述例子中可以看到我们的 <code class="language-plaintext highlighter-rouge">handleSubmit</code> 会依赖 <code class="language-plaintext highlighter-rouge">text</code> 的更新而去更新，在 <code class="language-plaintext highlighter-rouge">input</code> 的使用中 <code class="language-plaintext highlighter-rouge">text</code> 的变化肯定是相当频繁的，假如这时候我们的 <code class="language-plaintext highlighter-rouge">OtherForm</code> 是一个很大的组件，必须要进行优化这个时候可以使用 <code class="language-plaintext highlighter-rouge">useRef</code> 来帮忙。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">textRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">text</span><span class="p">,</span> <span class="nx">setText</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">textRef</span><span class="p">.</span><span class="nx">current</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">textRef</span><span class="p">]);</span>

<span class="k">return</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">form</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">input</span>
      <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span>
      <span class="nx">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span> <span class="nx">value</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">;</span>
        <span class="nx">setText</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="nx">textRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
      <span class="p">}}</span>
    <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">OtherForm</span> <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="nx">handleSubmit</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/form</span><span class="err">&gt;
</span><span class="p">);</span>
</code></pre></div></div>

<p>使用 <code class="language-plaintext highlighter-rouge">useRef</code> 可以生成一个变量让其在组件每个生命周期内都能访问到，且 <code class="language-plaintext highlighter-rouge">handleSubmit</code> 并不会因为 <code class="language-plaintext highlighter-rouge">text</code> 的更新而更新，也就不会让 <code class="language-plaintext highlighter-rouge">OtherForm</code> 多次渲染。</p>

<hr />

<p>评论中有为朋友提到是否要把所有的方法都用 useCallback 包一层呢，这个应该也是很多刚了解 useCallback 的朋友的一疑问。先说答案是：<strong>不要把所有的方法都包上 useCallback</strong>，下面仔细讲。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">count1</span><span class="p">,</span> <span class="nx">setCount1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">count2</span><span class="p">,</span> <span class="nx">setCount2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">handleClickButton1</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setCount1</span><span class="p">(</span><span class="nx">count1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">handleClickButton2</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setCount2</span><span class="p">(</span><span class="nx">count2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">count2</span><span class="p">]);</span>

<span class="k">return</span> <span class="p">(</span>
  <span class="o">&lt;&gt;</span>
    <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClickButton1</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">button1</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClickButton2</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">button2</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span><span class="p">);</span>
</code></pre></div></div>

<p>上面这种写法在当前组件重新渲染时会声明一个新的 <code class="language-plaintext highlighter-rouge">handleClickButton1</code> 函数，下面 <code class="language-plaintext highlighter-rouge">useCallback</code> 里面的函数也会声明一个新的函数，被传入到 <code class="language-plaintext highlighter-rouge">useCallback</code> 中，尽管这个函数有可能因为 <code class="language-plaintext highlighter-rouge">inputs</code> 没有发生改变不会被返回到 <code class="language-plaintext highlighter-rouge">handleClickButton2</code> 变量上。</p>

<p>那么在我们这种情况它返回新的函数和老的函数也都一样，因为下面 <code class="language-plaintext highlighter-rouge">&lt;button&gt;</code> 已经都会被渲染一下，反而使用 <code class="language-plaintext highlighter-rouge">useCallback</code> 后每次执行到这里内部要要比对 <code class="language-plaintext highlighter-rouge">inputs</code> 是否变化，还有存一下之前的函数，消耗更大了。</p>

<blockquote>
  <p>useCallback 是要配合子组件的 <strong><code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code></strong> 或者 <strong><code class="language-plaintext highlighter-rouge">React.memo</code></strong> 一起来使用的，否则就是反向优化。</p>
</blockquote>

<h2 id="usememo">useMemo</h2>

<h3 id="usememo-的作用">useMemo 的作用</h3>

<p>官方文档：</p>

<blockquote>
  <p>Pass a “create” function and an array of dependencies. useMemo will only recompute the memoized value when one of the dependencies has changed.</p>
</blockquote>

<p>简单来说就是传递一个创建函数和依赖项，创建函数会需要返回一个值，只有在依赖项发生改变的时候，才会重新调用此函数，返回一个新的值。</p>

<h3 id="usememo-的应用">useMemo 的应用</h3>

<p>useMemo 与 useCallback 很像，根据上述 useCallback 已经可以想到 useMemo 也能针对传入子组件的值进行缓存优化。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ...</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">userInfo</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="na">age</span><span class="p">:</span> <span class="nx">count</span><span class="p">,</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Jace</span><span class="dl">'</span>
<span class="p">}</span>

<span class="k">return</span> <span class="o">&lt;</span><span class="nx">UserCard</span> <span class="nx">userInfo</span><span class="o">=</span><span class="p">{</span><span class="nx">userInfo</span><span class="p">}</span><span class="o">&gt;</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ...</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">userInfo</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Jace</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="nx">count</span>
  <span class="p">};</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">count</span><span class="p">]);</span>

<span class="k">return</span> <span class="o">&lt;</span><span class="nx">UserCard</span> <span class="nx">userInfo</span><span class="o">=</span><span class="p">{</span><span class="nx">userInfo</span><span class="p">}</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>很明显的上面的 userInfo 每次都将是一个新的对象，无论 <code class="language-plaintext highlighter-rouge">count</code> 发生改变没，都会导致 UserCard 重新渲染，而下面的则会在 <code class="language-plaintext highlighter-rouge">count</code> 改变后才会返回新的对象。</p>

<p>上述用法是有有关于父子组件传值带来的性能优化，实际上 useMemo 的作用<strong>不止于此</strong>，根据官方文档内介绍：</p>

<blockquote>
  <p>This optimization helps to avoid expensive calculations on every render.</p>
</blockquote>

<p>可以把一些昂贵的计算逻辑放到 useMemo 中，只有当依赖值发生改变的时候才去更新。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 这里使用 count 针对 num 做一些很复杂的计算，当 count 没改变的时候，组件重新渲染就会直接返回之前缓存的值。</span>
  <span class="k">return</span> <span class="nx">num</span><span class="p">;</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">count</span><span class="p">]);</span>

<span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">num</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span></code></pre></div></div>

<p>事实上在使用中 useMemo 的场景远比 useCallback 要广泛的很多，我们可以将 useMemo 的返回值定义为返回一个函数这样就可以变通的实现了 useCallback。在开发中当我们有部分变量改变时会影响到多个地方的更新那我们就可以返回一个对象或者数组，通过解构赋值的方式来实现同时对多个数据的缓存。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">age</span><span class="p">,</span> <span class="nx">followUser</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span>
    <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getFullYear</span><span class="p">()</span> <span class="o">-</span> <span class="nx">userInfo</span><span class="p">.</span><span class="nx">birth</span><span class="p">,</span> <span class="c1">// 根据生日计算年龄</span>
    <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 关注用户</span>
      <span class="k">await</span> <span class="nx">request</span><span class="p">(</span><span class="dl">"</span><span class="s2">/follow</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span> <span class="na">uid</span><span class="p">:</span> <span class="nx">userInfo</span><span class="p">.</span><span class="nx">id</span> <span class="p">});</span>
      <span class="c1">// ...</span>
    <span class="p">},</span>
  <span class="p">];</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">userInfo</span><span class="p">]);</span>

<span class="k">return</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;</span><span class="nx">name</span><span class="p">:</span> <span class="p">{</span><span class="nx">userInfo</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/span</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;</span><span class="nx">age</span><span class="p">:</span> <span class="p">{</span><span class="nx">age</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/span</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">Card</span> <span class="nx">followUser</span><span class="o">=</span><span class="p">{</span><span class="nx">followUser</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="p">{</span><span class="nx">useMemo</span><span class="p">(</span>
      <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span>
        <span class="c1">// 如果 Card1 组件内部没有使用 React.memo 函数，那还可以通过这种方式在父组件减少子组件的渲染</span>
        <span class="o">&lt;</span><span class="nx">Card1</span> <span class="nx">followUser</span><span class="o">=</span><span class="p">{</span><span class="nx">followUser</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="p">),</span>
      <span class="p">[</span><span class="nx">followUser</span><span class="p">]</span>
    <span class="p">)}</span>
  <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="结语">结语</h2>

<p>简单理解呢 useCallback 与 useMemo 一个缓存的是函数，一个缓存的是函数的返回值。useCallback 是来优化子组件的，防止子组件的重复渲染。useMemo 可以优化当前组件也可以优化子组件，优化当前组件主要是通过 memoize 来将一些复杂的计算逻辑进行缓存。当然如果只是进行一些简单的计算也没必要使用 useMemo，这里可以考虑一些计算的性能消耗和比较 inputs 的性能消耗来做一个权衡（如果真有逻辑跟这个比较逻辑差不多，也没必要使用 useMemo ，还能减少一点对键盘磨损 😅）。</p>

<p>结束。</p>

        <div class="date">发布时间：2020-03-24</div>
      </div>
    </div>
    <div class="nav-container">
      <div class="main-nav">
        <div class="title">目录</div>
      </div>
    </div>
  </div>
  <footer id="footer">
  <a title="Github" href="https://github.com/jaceyi">
    <i class="iconfont">&#xe600;</i>
  </a>
  <a title="掘金" href="https://juejin.im/user/5a3b2016f265da43231b22a7">
    <i class="iconfont">&#xe610;</i>
  </a>
  <a title="个人网站" href="https://jaceyi.com/">
    <i class="iconfont">&#xe789;</i>
  </a>
  <a title="Twitter" href="https://twitter.com/jaceyi123">
    <i class="iconfont">&#xe602;</i>
  </a>
</footer>

  <div class="back-top">
  <i class="iconfont">&#xe6d9;</i>
</div>
<script>
  (function (d, w) {
    function scrollTo(targetY) {
      var currentY =
        d.documentElement.scrollTop || d.body.scrollTop;
      var distance = targetY - currentY;
      var num = 0;

      function animate() {
        var currentY =
          d.documentElement.scrollTop || d.body.scrollTop;
        w.scrollTo(0, currentY + distance / 10);
        num++;
        if (num === 10) return;
        w.requestAnimationFrame(animate);
      }

      animate();
    }
    var $upTop = d.querySelector('.back-top');

    $upTop.onclick = function () {
      scrollTo(0);
    };

    function bindEvent() {
      var scrollTop = d.documentElement.scrollTop || d.body.scrollTop;
      if (scrollTop > 100) {
        $upTop.style.display = 'block';
      } else {
        $upTop.style.display = 'none';
      }
    }

    w.addEventListener('scroll', bindEvent);
    w.addEventListener('load', bindEvent);
  })(document, window);
</script>

  <script src="/js/prism.js"></script>
  <script>
    (function (w, d) {
      var $nav = document.querySelector('.main-nav');
      var $article = document.querySelector('.article');
      var titleNodeNames = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];
      var contentItems = [];
      var navItems = [];
      for (var i = 0; i < $article.children.length; i++) {
        var element = $article.children[i];
        if (titleNodeNames.includes(element.nodeName)) {
          var link = document.createElement('a');
          link.href = '#' + element.innerText;
          link.innerText = element.innerText;
          link.setAttribute('data-head', element.nodeName)

          $nav.appendChild(link);
          navItems.push(link);
          element.id = element.innerText;
          contentItems.push(element);
        }
      }

      function bindEvent() {
        var scrollTop = d.documentElement.scrollTop || d.body.scrollTop;
        for (var i = 0; i < navItems.length; i++) {
          removeClass(navItems[i], 'active');
        }
        for (var i = contentItems.length - 1; i >= 0; i--) {
          if (scrollTop >= getElementTop(contentItems[i])) {
            addClass(navItems[i], 'active');
            return;
          }
        }
        addClass(navItems[0], 'active');
      }
      w.addEventListener('scroll', bindEvent);
      w.addEventListener('load', bindEvent);
    })(window, document)
  </script>
</body>

</html>
